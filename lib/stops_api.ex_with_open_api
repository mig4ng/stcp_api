defmodule StopsAPI do
  use Plug.Router

  plug(:match)
  plug(OpenApiSpex.Plug.PutApiSpec, module: __MODULE__)
  plug(:dispatch)

  def spec do
    %OpenApiSpex.OpenApi{
      info: %OpenApiSpex.Info{
        title: "STCP Stops API",
        version: "1.0.0",
        description: "API for fetching STCP bus stop information"
      },
      servers: [
        %OpenApiSpex.Server{url: "http://localhost:4000", description: "Development server"}
      ],
      paths: %{
        "/stops/{paragem}" => %OpenApiSpex.PathItem{
          get: %OpenApiSpex.Operation{
            operationId: "get_stops",
            summary: "Get bus stops information",
            description: "Fetches bus stop information for a given paragem (stop) ID",
            parameters: [
              %OpenApiSpex.Parameter{
                name: :paragem,
                in: :path,
                required: true,
                schema: %OpenApiSpex.Schema{type: :string},
                description: "The paragem (bus stop) identifier"
              }
            ],
            responses: %{
              200 => %OpenApiSpex.Response{
                description: "Successful response",
                content: %{
                  "application/json" => %OpenApiSpex.MediaType{
                    schema: %OpenApiSpex.Schema{
                      type: :array,
                      items: %OpenApiSpex.Schema{
                        type: :array,
                        items: %OpenApiSpex.Schema{type: :string},
                        minItems: 3,
                        maxItems: 3
                      }
                    }
                  }
                }
              },
              500 => %OpenApiSpex.Response{
                description: "Server error",
                content: %{
                  "application/json" => %OpenApiSpex.MediaType{
                    schema: %OpenApiSpex.Schema{
                      type: :object,
                      properties: %{
                        error: %OpenApiSpex.Schema{type: :string}
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  end

  # Serve OpenAPI documentation at /docs
  get "/docs" do
    html = """
    <!DOCTYPE html>
    <html>
      <head>
        <title>STCP Stops API Documentation</title>
        <link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui.css" />
      </head>
      <body>
        <div id="swagger-ui"></div>
        <script src="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-bundle.js"></script>
        <script>
          SwaggerUIBundle({
            url: '/openapi.json',
            dom_id: '#swagger-ui',
            presets: [
              SwaggerUIBundle.presets.apis,
              SwaggerUIBundle.presets.standalone
            ]
          });
        </script>
      </body>
    </html>
    """

    conn
    |> put_resp_content_type("text/html")
    |> send_resp(200, html)
  end

  # Serve OpenAPI spec as JSON
  get "/openapi.json" do
    spec = spec()

    conn
    |> put_resp_content_type("application/json")
    |> send_resp(200, Jason.encode!(spec))
  end

  # GET /stops/:paragem
  get "/stops/:paragem" do
    case get_stops(paragem) do
      {:ok, result} ->
        conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, Jason.encode!(result))

      {:error, _reason} ->
        conn
        |> put_resp_content_type("application/json")
        |> send_resp(500, Jason.encode!(%{error: "Failed to fetch stops"}))
    end
  end

  match _ do
    send_resp(conn, 404, "Not found")
  end

  defp get_stops(paragem) do
    url =
      "https://www.stcp.pt/pt/widget/post.php?uid=d72242190a22274321cacf9eadc7ec5f&paragem=#{paragem}"

    case HTTPoison.get(url, [], hackney: [insecure: true]) do
      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->
        cleaned_html = body |> String.trim() |> String.split() |> Enum.join(" ")

        case parse_stops(cleaned_html) do
          {:ok, stops_lines} -> {:ok, batch_stops(stops_lines)}
          error -> error
        end

      {:ok, %HTTPoison.Response{status_code: status_code}} ->
        {:error, "HTTP #{status_code}"}

      {:error, %HTTPoison.Error{reason: reason}} ->
        {:error, reason}
    end
  end

  defp parse_stops(html) do
    try do
      case Floki.parse_document(html) do
        {:ok, document} ->
          stops_lines =
            document
            |> Floki.find("div.floatLeft")
            |> Enum.filter(&has_linha_class?/1)
            |> Enum.map(&extract_and_format_text/1)

          {:ok, stops_lines}

        {:error, reason} ->
          {:error, reason}
      end
    rescue
      e -> {:error, e}
    end
  end

  defp has_linha_class?({_tag, attributes, _children}) do
    case List.keyfind(attributes, "class", 0) do
      {"class", class_string} -> String.contains?(class_string, "Linha")
      nil -> false
    end
  end

  defp extract_and_format_text(element) do
    element
    |> Floki.text()
    |> format_text()
  end

  defp format_text(raw_text) do
    raw_text
    # Uncomment if you want text without special characters
    # |> String.replace(~r/[àáâãäå]/, "a")
    # |> String.replace(~r/[ÀÁÂÃÄÅ]/, "A")
    # |> String.replace(~r/[èéêë]/, "e")
    # |> String.replace(~r/[ÈÉÊË]/, "E")
    # |> String.replace(~r/[ìíîï]/, "i")
    # |> String.replace(~r/[ÌÍÎÏ]/, "I")
    # |> String.replace(~r/[òóôõö]/, "o")
    # |> String.replace(~r/[ÒÓÔÕÖ]/, "O")
    # |> String.replace(~r/[ùúûü]/, "u")
    # |> String.replace(~r/[ÙÚÛÜ]/, "U")
    # |> String.replace(~r/[ýÿ]/, "y")
    # |> String.replace(~r/[ÝŸ]/, "Y")
    # |> String.replace(~r/[ß]/, "ss")
    # |> String.replace(~r/[ñ]/, "n")
    # |> String.replace(~r/[Ñ]/, "N")
    # |> String.replace(" ", "")
    # |> String.replace("\t", "")
  end

  defp batch_stops(stops_lines) do
    stops_lines
    |> Enum.drop(3)
    |> Enum.chunk_every(3)
  end
end

# Application supervisor and startup
defmodule StopsAPI.Application do
  use Application

  def start(_type, _args) do
    children = [
      {Plug.Cowboy, scheme: :http, plug: StopsAPI, options: [port: 4000]}
    ]

    opts = [strategy: :one_for_one, name: StopsAPI.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
